\begin{frame}[fragile]
\begin{block}{Schemat algorytmu SGA}
\begin{lstlisting}[mathescape][language=python]
def SGA(F, N, M, $\theta_C$, $\theta_M$):
    P = RANDOM-POPULATION(N)
    POPULATION-EVALUATION(P, F)
    while not TERMINATION-CONDITION(P):
        PS = PARENT-SELECTION(P)
        PC = CROSSOVER(PS, $\theta_C$)
        P = MUTATION(PC, $\theta_M$)
        POPULATION-EVALUATION(P, F)
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]
\begin{block}{Operator krzyżowania}
Operator PMX
\begin{itemize}
\item Każdy z rodziców jest dzielony na trzy segmenty,
\item środkowe segmenty zostają wymienione ze sobą,
\item pozostałe segmenty przepisujemy naprawiając własność permutacji.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\begin{block}{Operatory mutacji}
Wykorzystaliśmy dwa operatory, w każdej mutacji wybierany jest jeden z nich z jednakowym prawdopodobieństwem.
\begin{itemize}
\item swap mutation \\
1 2 \textbf{3} 4 5 6 \textbf{7} 8 9 10 \\
1 2 \textbf{7} 4 5 6 \textbf{3} 8 9 10 \\
\item shift mutation \\ 
1 2 \textbf{3 4 5 6 7} 8 9 10 \\
1 2 \textbf{4 5 6 7 3} 8 9 10 \\
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\begin{block}{Replacement}
Wybraliśmy wariant $(\mu + \lambda)$, tj. w każdej kolejnej iteracji populacja wybierana jest z najlepszych osobników zarówno z rodziców jak i z dzieci.
\end{block}
\end{frame}
